%{
    #include "y.tab.h"    // Include the header generated by Bison/Yacc
    #include "symbol.h"   // Include the symbol header
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>

    char str[1024];  // Buffer for string literals

    // Prototype for yyparse
    extern int yyparse();
%}

%%
[ \t]+     {/* Ignore whitespace and tabs */}
"//".*     {/* Ignore single-line comments */}
"if"       { return IF; }
"then"     { return THEN; }
"else"     { return ELSE; }
"endif"    { return ENDIF; }
"print"    { return PRINT; }
"newline"  { return NEWLINE; }
"bye"      { return BYE; }
";"        { return SEMICOLON; }
"+"        { return PLUS; }
"-"        { return MINUS; }
"*"        { return MULT; }
"/"        { return DIV; }
"="        { return ASSIGN; }
"<="       { return LE; }
">="       { return GE; }
"=="       { return EQU; }
"!="       { return NE; }
"<"        { return LESSER; }
">"        { return GREATER; }
"("        { return LPEREN; }
")"        { return RPEREN; }

[0-9]+    {
                yylval.int_val = atoi(yytext);
                return INTEGER;
          }

\"(.*?)\" {
                strncpy(str, &(yytext[1]), strlen(yytext)-2);
                str[strlen(yytext)-2] = '\0';
                yylval.strval = strdup(str);
                return STRING_LITERAL;
          }

[a-zA-Z_][a-zA-Z0-9_]* {
                int idx = find_symbol(yytext);
                if (idx == -1) {
                    idx = add_symbol(yytext);  // Add new identifier
                }
                yylval.sym_index = idx;  // Pass the symbol table index to Yacc
                return ID;
          }

\n        {/* Ignore newlines */}
.         { printf("Input Not Recognized: %s\n", yytext); }

%%

int yywrap(void) {
    return 1;  // Indicate end of input
}

int main(int argc, char** argv) {
    // Start parsing with yyparse
    return yyparse();
}
