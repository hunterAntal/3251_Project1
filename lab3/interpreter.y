%{
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>

    // Maximum number of symbols allowed in the symbol table
    #define MAX_SYMBOLS 100

    // Structure representing a variable: name, value, and initialization flag
    typedef struct {
        char* name;     // Variable name
        int value;      // Variable value
        int initialized; // Indicates if the variable has been initialized
    } Symbol;

    // Symbol table and a counter for the number of symbols
    Symbol symbol_table[MAX_SYMBOLS];
    int symbol_count = 0;

    // Function to find a symbol by name in the symbol table
    // Returns the index if found, otherwise returns -1
    int find_symbol(const char* name) {
        for (int i = 0; i < symbol_count; ++i) {
            if (strcmp(symbol_table[i].name, name) == 0) {
                return i;
            }
        }
        return -1;
    }

    // Function to add a new symbol to the symbol table
    // Returns the index where the symbol was added
    int add_symbol(const char* name) {
        if (symbol_count >= MAX_SYMBOLS) {
            fprintf(stderr, "Error: Symbol table overflow\n");
            exit(1);
        }
        symbol_table[symbol_count].name = strdup(name); // Duplicate the name
        symbol_table[symbol_count].value = 0;
        symbol_table[symbol_count].initialized = 0;
        return symbol_count++;
    }

    // Error handling function
    void yyerror(const char *s);
    
    // Declaration of yylex (generated by Flex)
    extern int yylex(void);

%}

%union {
    int int_val;       // For integer values
    char* strval;      // For identifiers and string literals
}

// Token declarations
%token IF BYE THEN ELSE ENDIF PRINT NEWLINE SEMICOLON
%token EQU LESSER GREATER LE GE NE
%token PLUS MINUS MULT DIV LPEREN RPEREN ASSIGN
%token <strval> STRING_LITERAL
%token <int_val> INTEGER
%token <strval> ID
%type <int_val> expr

// Operator precedence and associativity rules
%left PLUS MINUS
%left MULT DIV
%nonassoc LESSER GREATER LE GE EQU NE
%right ASSIGN

%%

// Program starts with a list of statements
program:
    stmt_list
    ;

// List of statements (supports multiple statements)
stmt_list:
    statement stmt_list
    | /* empty */  // Allows an empty statement list
    ;

// A single statement can be an assignment, if statement, print statement, or 'bye'
statement:
    assign_stmt
    | if_stmt
    | print_statement
    | bye_statement
    ;

// Assignment statement: ID = expr;
assign_stmt:
    ID ASSIGN expr SEMICOLON {
        int idx = find_symbol($1);
        if (idx == -1) {
            idx = add_symbol($1);  // Add new variable if not found
        }
        symbol_table[idx].value = $3;  // Assign value
        symbol_table[idx].initialized = 1;  // Mark as initialized
        free($1); // Free the duplicated string
    }
    ;

// Print statement: print STRING_LITERAL; or print expr; or print newline;
print_statement:
    PRINT STRING_LITERAL SEMICOLON {
        printf("%s", $2);  // Print string
        free($2); // Free the duplicated string
    }
    | PRINT expr SEMICOLON {
        printf("%d", $2);  // Print evaluated expression
    }
    | PRINT NEWLINE SEMICOLON {
        printf("\n");  // Print a newline
    }
    ;

// If-else statement: if expr then stmt_list else stmt_list endif
if_stmt:
    IF expr THEN stmt_list ELSE stmt_list ENDIF
    ;

// Expression rules: supports arithmetic, comparison, parentheses, and variables
expr:
    expr PLUS expr       { $$ = $1 + $3; }  // Addition
    | expr MINUS expr    { $$ = $1 - $3; }  // Subtraction
    | expr MULT expr     { $$ = $1 * $3; }  // Multiplication
    | expr DIV expr      {
        if ($3 == 0) {
            yyerror("Error: Division by zero");
            $$ = 0;
        } else {
            $$ = $1 / $3;  // Division
        }
    }
    | expr LESSER expr   { $$ = ($1 < $3) ? 1 : 0; }  // Less than
    | expr GREATER expr  { $$ = ($1 > $3) ? 1 : 0; }  // Greater than
    | expr LE expr       { $$ = ($1 <= $3) ? 1 : 0; }  // Less than or equal to
    | expr GE expr       { $$ = ($1 >= $3) ? 1 : 0; }  // Greater than or equal to
    | expr EQU expr      { $$ = ($1 == $3) ? 1 : 0; }  // Equal to
    | expr NE expr       { $$ = ($1 != $3) ? 1 : 0; }  // Not equal to
    | LPEREN expr RPEREN { $$ = $2; }  // Parentheses
    | MINUS expr %prec MINUS { $$ = -$2; }  // Unary minus
    | INTEGER            { $$ = $1; }  // Integer literal
    | ID {
        int idx = find_symbol($1);
        if (idx == -1 || !symbol_table[idx].initialized) {
            yyerror("Error: Variable used before assignment");
            $$ = 0;
        } else {
            $$ = symbol_table[idx].value;  // Retrieve variable value
        }
        free($1); // Free the duplicated string
    }
    ;

// Bye statement: exit the program
bye_statement:
    BYE SEMICOLON { 
        printf("Good Bye Cruel World\n"); 
        exit(0);  // Terminate the program
    }
    ;

%%

// Error handling function: prints error message to stderr
void yyerror(const char *s) {
    fprintf(stderr, "%s\n", s);
}
